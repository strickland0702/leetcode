## 二叉树

#### [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

```python
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        stack, preorder = [], []
        node = root

        while node or stack:
            if node:
                preorder.append(node.val)
                stack.append(node)
                node = node.left
            else:
                node = stack.pop()
                node = node.right

        return preorder
```

#### [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

```python
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        stack, inorder = [], []
        node = root

        while stack or node:
            if node:
                stack.append(node)
                node = node.left
            else:
                node = stack.pop()
                inorder.append(node.val)
                node = node.right

        return inorder
```

#### [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

```python
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:

        # 后序遍历：左右根

        stack, postorder = [],[]
        node = root

        while stack or node:
            if node:
                postorder.append(node.val)
                stack.append(node)
                node = node.right
            else:
                node = stack.pop()
                node = node.left

        return postorder[::-1]
```

## 层序遍历(BFS)

#### [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

```python
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        result = []
        if not root:
            return result

        queue = collections.deque([root])
        
        while queue:
            result.append([])
            level_size = len(queue)
            for _ in range(level_size):
                node = queue.popleft()
                result[-1].append(node.val)
                if node.left:
                    queue.append(node.left)

                if node.right:
                    queue.append(node.right)

        return result
```

#### [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

```python
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        # 层序遍历

        if not root:
            return root

        queue = collections.deque([root])

        while queue:
            node = queue.popleft()
            # 交换两个node，相当与交换了以这两个node为根节点的整个子树
            node.left, node.right = node.right, node.left

            if node.left:
                queue.append(node.left)

            if node.right:
                queue.append(node.right) 

        return root
    
        # 递归
        def process(node):
            if not node:
                return 

            process(node.left)
            process(node.right)

            node.left, node.right = node.right, node.left #这句话放在最前面也对，变为前序

        process(root)
        return root
```

#### [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

```python
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        # 层序遍历序列化
        
        if not root:
            return True

        queue = collections.deque([root])
        
        while queue:
            result = []
            level_size = len(queue)
            for _ in range(level_size):
                node = queue.popleft()
                
                if node.left:
                    queue.append(node.left)
                    result.append(node.left.val)
                else:
                    result.append("#")

                if node.right:
                    queue.append(node.right)
                    result.append(node.right.val)
                else:
                    result.append("#")

            if result != result[::-1]:
                return False
 
        return True

        # 前序递归
        def process(node1, node2) -> bool:
            if not node1 and not node2:
                return True
            elif (not node1 and node2) or (not node2 and node1):
                return False

            # 当前两个节点值相等，且左对右，右对左
            return node1.val == node2.val and process(node1.left, node2.right) and process(node1.right, node2.left)

        return process(root, root)
                    
```

## 二叉树的递归(DFS)

二叉树的递归问题分为两种：

1）需要直接处理当前node节点，不需要从左右子树收集信息，一般为操作类。此时应使用前序遍历，顺序为base case, 当前节点处理，左子树，右子树。

2）需要从左右子树收集完信息之后，才能对得出当前节点性质，一般为数值类。此时应使用后序遍历，顺序为base case, 左子树，右子树，当前节点处理。（左神模板）

### 后序递归问题

#### [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

```python
class Info:
    def __init__(self, balance, height) -> None:
        self.balance = balance
        self.height = height

class Solution:
    def isBalanced(self, root: TreeNode) -> bool:

        def process(node):
            if not node:
                return Info(True, 0)

            leftinfo = process(node.left)
            rightinfo = process(node.right)

            balance = True
            if not leftinfo.balance or not rightinfo.balance or abs(leftinfo.height - rightinfo.height) > 1:
                balance = False
            
            height = max(leftinfo.height, rightinfo.height) + 1

            return Info(balance, height)

        return process(root).balance
```

#### [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

```python
class Info:
    def __init__(self, isbst, min_, max_) -> None:
        self.isbst = isbst
        self.min_ = min_
        self.max_ = max_

class Solution:
    def isValidBST(self, root: TreeNode) -> bool:

        def process(node):
            if not node:
                return None

            leftinfo = process(node.left)
            rightinfo = process(node.right)

            min_ = node.val
            if leftinfo:
                min_ = min(min_, leftinfo.min_)
            if rightinfo:
                min_ = min(min_, rightinfo.min_)

            max_ = node.val
            if leftinfo:
                max_ = max(max_, leftinfo.max_)
            if rightinfo:
                max_ = max(max_, rightinfo.max_)

            isbst = True
            if leftinfo and (leftinfo.max_ >= node.val or not leftinfo.isbst):
                isbst = False        

            if rightinfo and (rightinfo.min_ <= node.val or not rightinfo.isbst):
                isbst = False
                
            return Info(isbst, min_, max_)

        if not root:
            return True

        return process(root).isbst
```

#### [剑指 Offer 55 - I. 二叉树的深度](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/)

```python
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        # 层序遍历，数层数

        # if not root:
        #     return 0

        # queue = collections.deque([root])
        # depth = 0

        # while queue:
        #     depth += 1
        #     level_size = len(queue)
            
        #     for _ in range(level_size):
        #         node = queue.popleft()

        #         if node.left:
        #             queue.append(node.left)

        #         if node.right:
        #             queue.append(node.right)

        # return depth

        # 递归
        def process(node):
            if not node:
                return 0

            leftheight = process(node.left)
            rightheight = process(node.right)

            height = max(leftheight, rightheight) + 1

            return height

        return process(root)
```

#### [222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

```python
class Solution:
    def countNodes(self, root: TreeNode) -> int:
        # 递归

        def process(node):
            if not node:
                return 0

            left = process(node.left)
            right = process(node.right)

            node_number = left + right + 1

            return node_number

        return process(root)

        # 前序，中序，后序，层序遍历，数节点
```

#### [235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':

        # 如果p,q位于root的左子树
        if root.val > max(p.val, q.val):
            return self.lowestCommonAncestor(root.left, p, q)

        # 如果p,q位于root的右子树
        elif root.val < min(p.val, q.val):
            return self.lowestCommonAncestor(root.right, p, q)
        
        # 如果p,q位于root的两侧，或root等于p或q中的一个，则root为p,q的公共祖先
        else:
            return root
```

#### [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

#### [剑指 Offer 68 - II. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

```python
class Info:
    def __init__(self, finda, findb, ans) -> None:
        self.finda = finda
        self.findb = findb
        self.ans = ans

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':

        def process(node, p, q):
            if not node:
                return Info(False, False, None)

            leftinfo = process(node.left, p, q)
            rightinfo = process(node.right, p, q)

            finda = (node == p or leftinfo.finda or rightinfo.finda)
            findb = (node == q or leftinfo.findb or rightinfo.findb)

            ans = None
            if leftinfo.ans:
                ans = leftinfo.ans
            
            elif rightinfo.ans:
                ans = rightinfo.ans

            # 如果左右都没有ans，但是又能找到p和q，说明p和q在两侧或node为p和q的一个，返回当前节点node
            elif finda and findb:
                ans = node

            return Info(finda, findb, ans)

        return process(root, p, q).ans
```

#### [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

```python
class Info:
    def __init__(self, maxsum, nodemax) -> None:
        self.maxsum = maxsum
        self.nodemax = nodemax

class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:

        def process(node):
            if not node:
                return None 

            leftinfo = process(node.left)
            rightinfo = process(node.right)

            nodemax = node.val
            maxsum = node.val

            if leftinfo and not rightinfo:
                nodemax += max(0, leftinfo.nodemax)
                maxsum = max(leftinfo.maxsum, node.val + max(0, leftinfo.nodemax))
            if rightinfo and not leftinfo:
                nodemax += max(0, rightinfo.nodemax)
                maxsum = max(rightinfo.maxsum, node.val + max(0, rightinfo.nodemax))
            if leftinfo and rightinfo:
                nodemax += max(0, leftinfo.nodemax, rightinfo.nodemax)
                maxsum = max(leftinfo.maxsum, rightinfo.maxsum, node.val + max(0, leftinfo.nodemax) + max(0, rightinfo.nodemax))

            return Info(maxsum, nodemax)

        return process(root).maxsum
```

#### [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

```
class Solution:
    def minDepth(self, root: TreeNode) -> int:

        def process(node):
            if not node:
                return None

            leftheight = process(node.left)
            rightheight = process(node.right)

            height = 1
            if leftheight and not rightheight:
                height += leftheight
            elif not leftheight and rightheight:
                height += rightheight
            elif leftheight and rightheight:
                height += min(leftheight, rightheight)

            return height
        
        if not root:
            return 0
            
        return process(root)
```

#### [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

```python
class Info:
    def __init__(self, maxdis, depth) -> None:
        self.maxdis = maxdis
        self.depth = depth

class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:

        def process(node):
            if not node:
                return Info(0, 0)

            leftinfo = process(node.left)
            rightinfo = process(node.right)

            depth = max(leftinfo.depth, rightinfo.depth) + 1

            maxdis = max(leftinfo.maxdis, rightinfo.maxdis, leftinfo.depth + rightinfo.depth)

            return Info(maxdis, depth)

        return process(root).maxdis
```

#### [95. 不同的二叉搜索树 II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def generateTrees(self, n: int) -> List[TreeNode]:

        # 返回从start到end区间可以生产的所有二叉树
        def generate_trees(start, end):
            if start > end:
                return [None]

            results = []
            for i in range(start, end+1):
                lefttrees = generate_trees(start, i-1)
                righttrees = generate_trees(i+1, end)

                for l in lefttrees:
                    for r in righttrees:
                        node = TreeNode(i)
                        node.left = l
                        node.right = r  
                        results.append(node)

            return results

        return generate_trees(1, n) if n else []
```



### 前序递归问题

#### [剑指 Offer 27. 二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def mirrorTree(self, root: TreeNode) -> TreeNode:

        def process(node):
            if not node:
                return None

            node.left, node.right = node.right, node.left
            process(node.left)
            process(node.right)

            return node

        return process(root)
```

#### [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:

        def process(left, right):
            if left > right:
                return 

            mid = (left + right) // 2
            # 先将中间值建根节点
            root = TreeNode(nums[mid])
            # 再分别用左右数组建左右子树
            root.left = process(left, mid-1)
            root.right = process(mid+1, right)

            return root

        return process(0, len(nums)-1)
```

#### [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

```python
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:

        def process(node, target):
            if not node:
                return False

            if not node.left and not node.right:
                return node.val == target

            leftinfo = process(node.left, target - node.val)
            rightinfo = process(node.right, target - node.val)
    
            return leftinfo or rightinfo

        return process(root, targetSum)
```

#### [404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

```python
class Solution:
    def sumOfLeftLeaves(self, root: TreeNode) -> int:
        if not root:
            return 0
        
        isLeafNode = lambda node: not node.left and not node.right
        q = collections.deque([root])
        ans = 0

        while q:
            node = q.popleft()
            if node.left:
                # 如果在左侧并且是叶子节点，计入总和
                if isLeafNode(node.left):
                    ans += node.left.val
                else:
                    q.append(node.left)
            if node.right:
                # 在右侧
                if not isLeafNode(node.right):
                    q.append(node.right)
        
        return ans
```

#### [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

```python
class Solution:
    def binaryTreePaths(self, root: TreeNode) -> List[str]:
        def construct_paths(root, path):
            if root:
                path += str(root.val)
                if not root.left and not root.right:  # 当前节点是叶子节点
                    paths.append(path)  # 把路径加入到答案中
                else:
                    path += '->'  # 当前节点不是叶子节点，继续递归遍历
                    construct_paths(root.left, path)
                    construct_paths(root.right, path)

        paths = []
        construct_paths(root, '')
        return paths
```

#### [617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)

```python
class Solution:
    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:
        if not t1 and not t2:
            return None
        elif not t1 and t2:
            return t2
        elif not t2 and t1:
            return t1

        merged = TreeNode(t1.val + t2.val)
        merged.left = self.mergeTrees(t1.left, t2.left)
        merged.right = self.mergeTrees(t1.right, t2.right)
        
        return merged
```

#### [671. 二叉树中第二小的节点](https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/)

```python
class Solution:
    def findSecondMinimumValue(self, root: TreeNode) -> int:
        if not root or not root.left or not root.right:
            return -1

        left = root.left.val if root.val != root.left.val else self.findSecondMinimumValue(root.left)
        right = root.right.val if root.val != root.right.val else self.findSecondMinimumValue(root.right)

        return min(left, right) if left != -1 and right != -1 else max(left, right)
```

#### [572. 另一棵树的子树](https://leetcode-cn.com/problems/subtree-of-another-tree/)

```python
class Solution:
    def isSubtree(self, root: TreeNode, subRoot: TreeNode) -> bool:

        def compare(node1, node2) -> bool:
            if not node1 and not node2:
                return True
            elif (not node1 and node2) or (node1 and not node2):
                return False

            return node1.val == node2.val and compare(node1.left, node2.left) and compare(node1.right, node2.right)

        if not root:
            return False

        if not compare(root, subRoot): w
            return self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot)
        else:
            return True
```

### 二叉搜索树

二叉搜索树最大的性质为中序遍历是递增顺序，解题思路往上面靠。

#### [剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def kthLargest(self, root: TreeNode, k: int) -> int:

        # 中序遍历
        inorder = []
        def process(node):
            if not node:
                return 
                
            process(node.left)
            inorder.append(node.val)
            process(node.right)

        process(root)

        return inorder[-k]
```

#### [501. 二叉搜索树中的众数](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def findMode(self, root: TreeNode) -> List[int]:
        
        inorder = []

        def process(node):
            if not node:
                return 

            process(node.left)
            inorder.append(node.val)
            process(node.right)

        process(root)
        counts = Counter(inorder)

        max_count = 0
        max_ele = []
        
        for key, value in counts.items():
            if value > max_count:
                max_count = value
                max_ele = [key]
            elif value == max_count:
                max_ele.append(key)

        return max_ele
```

#### [99. 恢复二叉搜索树](https://leetcode-cn.com/problems/recover-binary-search-tree/)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def recoverTree(self, root: Optional[TreeNode]) -> None:
        """
        Do not return anything, modify root in-place instead.
        """

        # 中序遍历
        first, second = None, None
        pre = None
        stack = []
        node = root

        while node or stack:
            if node:
                stack.append(node)
                node = node.left
            else:
                cur = stack.pop()

                # 如果当前节点比前一个遍历的节点小，记录first和second
                if pre and pre.val >= cur.val:
                    # first只在第一次违反时记录
                    if not first:
                        first = pre

                    # second第二次记录会覆盖掉第一次的值
                    second = cur

                pre = cur
                node = cur.right

        first.val, second.val = second.val, first.val
```

#### [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

```python
class Solution:
    def numTrees(self, n: int) -> int:

        # 给定一个数组，可以以任意节点j作为根节点
        # 1..j-1 作为左子树，j+1 ...n作为右子树建立二叉搜索树

        dp = (n+1)*[0]

        dp[0], dp[1] = 1, 1

        for i in range(2, n+1):
            for j in range(1, i+1):
                dp[i] += (dp[j-1] * dp[i-j])

        return dp[n]
```

#### [109. 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:

        values = []
        cur = head

        while cur:
            values.append(cur.val)
            cur = cur.next

        def process(left, right):
            if left > right:
                return 

            mid = (left + right) // 2
            node = TreeNode(values[mid])
            node.left = process(left, mid - 1) 
            node.right = process(mid + 1, right)

            return node

        return process(0, len(values)-1)
```

#### [95. 不同的二叉搜索树 II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def generateTrees(self, n: int) -> List[TreeNode]:

        # 返回从start到end区间可以生产的所有二叉树
        def generate_trees(start, end):
            if start > end:
                return [None]

            results = []
            for i in range(start, end+1):
                lefttrees = generate_trees(start, i-1)
                righttrees = generate_trees(i+1, end)

                for l in lefttrees:
                    for r in righttrees:
                        node = TreeNode(i)
                        node.left = l
                        node.right = r  
                        results.append(node)

            return results

        return generate_trees(1, n) if n else []
```

