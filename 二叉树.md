## 二叉树

#### [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

```python
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        stack, preorder = [], []
        node = root

        while node or stack:
            if node:
                preorder.append(node.val)
                stack.append(node)
                node = node.left
            else:
                node = stack.pop()
                node = node.right

        return preorder
```

#### [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

```python
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        stack, inorder = [], []
        node = root

        while len(stack) > 0 or node:
            if node:
                stack.append(node)
                node = node.left
            else:
                node = stack.pop()
                inorder.append(node.val)
                node = node.right

        return inorder
```

#### [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

```python
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:

        # 后序遍历：左右根

        stack, postorder = [],[]
        node = root

        while stack or node:
            if node:
                postorder.append(node.val)
                stack.append(node)
                node = node.right
            else:
                node = stack.pop()
                node = node.left

        return postorder[::-1]
```

#### [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

```python
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        result = []
        if not root:
            return result

        queue = collections.deque([root])
        
        while queue:
            result.append([])
            level_size = len(queue)
            for _ in range(level_size):
                node = queue.popleft()
                result[-1].append(node.val)
                if node.left:
                    queue.append(node.left)

                if node.right:
                    queue.append(node.right)

        return result
```

#### [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

```python
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        # 层序遍历

        if not root:
            return root

        queue = collections.deque([root])

        while queue:
            node = queue.popleft()
            # 交换两个node，相当与交换了以这两个node为根节点的整个子树
            node.left, node.right = node.right, node.left

            if node.left:
                queue.append(node.left)

            if node.right:
                queue.append(node.right) 

        return root
    
        # 递归
        def process(node):
            if not node:
                return 

            process(node.left)
            process(node.right)

            node.left, node.right = node.right, node.left #这句话放在最前面也对，变为前序

        process(root)
        return root
```

#### [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

```python
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        # 层序遍历序列化
        
        if not root:
            return True

        queue = collections.deque([root])
        
        while queue:
            result = []
            level_size = len(queue)
            for _ in range(level_size):
                node = queue.popleft()
                
                if node.left:
                    queue.append(node.left)
                    result.append(node.left.val)
                else:
                    result.append("#")

                if node.right:
                    queue.append(node.right)
                    result.append(node.right.val)
                else:
                    result.append("#")

            if result != result[::-1]:
                return False
 
        return True
                    
```

## 二叉树的递归

#### [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

```python
class Info:
    def __init__(self, balance, height) -> None:
        self.balance = balance
        self.height = height

class Solution:
    def isBalanced(self, root: TreeNode) -> bool:

        def process(node):
            if not node:
                return Info(True, 0)

            leftinfo = process(node.left)
            rightinfo = process(node.right)

            balance = True
            if not leftinfo.balance or not rightinfo.balance or abs(leftinfo.height - rightinfo.height) > 1:
                balance = False
            
            height = max(leftinfo.height, rightinfo.height) + 1

            return Info(balance, height)

        return process(root).balance
```

#### [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

```python
class Info:
    def __init__(self, isbst, min_, max_) -> None:
        self.isbst = isbst
        self.min_ = min_
        self.max_ = max_

class Solution:
    def isValidBST(self, root: TreeNode) -> bool:

        def process(node):
            if not node:
                return None

            leftinfo = process(node.left)
            rightinfo = process(node.right)

            min_ = node.val
            if leftinfo:
                min_ = min(min_, leftinfo.min_)
            if rightinfo:
                min_ = min(min_, rightinfo.min_)

            max_ = node.val
            if leftinfo:
                max_ = max(max_, leftinfo.max_)
            if rightinfo:
                max_ = max(max_, rightinfo.max_)

            isbst = True
            if leftinfo and (leftinfo.max_ >= node.val or not leftinfo.isbst):
                isbst = False        

            if rightinfo and (rightinfo.min_ <= node.val or not rightinfo.isbst):
                isbst = False
                
            return Info(isbst, min_, max_)

        if not root:
            return True

        return process(root).isbst
```

#### [剑指 Offer 55 - I. 二叉树的深度](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/)

```python
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        # 层序遍历，数层数

        # if not root:
        #     return 0

        # queue = collections.deque([root])
        # depth = 0

        # while queue:
        #     depth += 1
        #     level_size = len(queue)
            
        #     for _ in range(level_size):
        #         node = queue.popleft()

        #         if node.left:
        #             queue.append(node.left)

        #         if node.right:
        #             queue.append(node.right)

        # return depth

        # 递归
        def process(node):
            if not node:
                return 0

            leftheight = process(node.left)
            rightheight = process(node.right)

            height = max(leftheight, rightheight) + 1

            return height

        return process(root)
```

#### [222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

```python
class Solution:
    def countNodes(self, root: TreeNode) -> int:
        # 递归

        def process(node):
            if not node:
                return 0

            left = process(node.left)
            right = process(node.right)

            node_number = left + right + 1

            return node_number

        return process(root)

        # 前序，中序，后序，层序遍历，数节点
```

#### [235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':

        # 如果p,q位于root的左子树
        if root.val > max(p.val, q.val):
            return self.lowestCommonAncestor(root.left, p, q)

        # 如果p,q位于root的右子树
        elif root.val < min(p.val, q.val):
            return self.lowestCommonAncestor(root.right, p, q)
        
        # 如果p,q位于root的两侧，则root为p,q的公共祖先
        else:
            return root
```

#### [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

```python
class Info:
    def __init__(self, finda, findb, ans) -> None:
        self.finda = finda
        self.findb = findb
        self.ans = ans

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':

        def process(node, p, q):
            if not node:
                return Info(False, False, None)

            leftinfo = process(node.left, p, q)
            rightinfo = process(node.right, p, q)

            finda = (node == p or leftinfo.finda or rightinfo.finda)
            findb = (node == q or leftinfo.findb or rightinfo.findb)

            ans = None
            if leftinfo.ans:
                ans = leftinfo.ans
            
            elif rightinfo.ans:
                ans = rightinfo.ans

            elif finda and findb:
                ans = node

            return Info(finda, findb, ans)

        return process(root, p, q).ans
```

#### [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

```python
class Info:
    def __init__(self, maxsum, nodemax) -> None:
        self.maxsum = maxsum
        self.nodemax = nodemax

class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:

        def process(node):
            if not node:
                return None 

            leftinfo = process(node.left)
            rightinfo = process(node.right)

            nodemax = node.val
            maxsum = node.val

            if leftinfo and not rightinfo:
                nodemax += max(0, leftinfo.nodemax)
                maxsum = max(leftinfo.maxsum, node.val + max(0, leftinfo.nodemax))
            if rightinfo and not leftinfo:
                nodemax += max(0, rightinfo.nodemax)
                maxsum = max(rightinfo.maxsum, node.val + max(0, rightinfo.nodemax))
            if leftinfo and rightinfo:
                nodemax += max(0, leftinfo.nodemax, rightinfo.nodemax)
                maxsum = max(leftinfo.maxsum, rightinfo.maxsum, node.val + max(0, leftinfo.nodemax) + max(0, rightinfo.nodemax))

            return Info(maxsum, nodemax)

        return process(root).maxsum
```

#### [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

```
class Solution:
    def minDepth(self, root: TreeNode) -> int:

        def process(node):
            if not node:
                return None

            leftheight = process(node.left)
            rightheight = process(node.right)

            height = 1
            if leftheight and not rightheight:
                height += leftheight
            elif not leftheight and rightheight:
                height += rightheight
            elif leftheight and rightheight:
                height += min(leftheight, rightheight)

            return height
        
        if not root:
            return 0
            
        return process(root)
```

#### [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

```python
class Info:
    def __init__(self, maxdis, depth) -> None:
        self.maxdis = maxdis
        self.depth = depth

class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:

        def process(node):
            if not node:
                return Info(0, 0)

            leftinfo = process(node.left)
            rightinfo = process(node.right)

            depth = max(leftinfo.depth, rightinfo.depth) + 1

            maxdis = max(leftinfo.maxdis, rightinfo.maxdis, leftinfo.depth + rightinfo.depth)

            return Info(maxdis, depth)

        return process(root).maxdis
```

