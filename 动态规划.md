# 动态规划

### 从左往右模型

序列index以前已经考虑好，考虑index以及之后的递归关系，终止条件为index到序列结尾时。主函数调用process(str, index = 0)

#### [剑指 Offer 46. 把数字翻译成字符串](https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)

```python
class Solution:
    def translateNum(self, num: int) -> int:

        chars = list(str(num))
        nums = [int(char) for char in chars]

        # 从index开始，往后有多少种翻译方法
        def process(nums, index):
            
            # 问方法数的题目，如果index停在最后，说明之前做的一系列决策是一种方法，应该return 1
            if index == len(nums):
                return 1

            ways = process(nums, index+1)

            if nums[index] != 0 and index + 1 < len(nums) and nums[index] * 10 + nums[index+1] < 26:
                ways += process(nums, index+2)

            return ways

        return process(nums, 0)
```

#### [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:

        # 凑成总金额amount的最少硬币个数
        # def process(coins, amount):
        #     if amount < 0:
        #         return math.inf

        #     if amount == 0:
        #         return 0

        #     # amount仍然大于0时
        #     ans = math.inf
        #     for coin in coins:
        #         ans = min(ans, process(coins, amount - coin))

        #     return ans + 1

        # result = process(coins, amount)
        # if result == math.inf:
        #     return -1
        # else:
        #     return result

        # 动态规划
        dp = (amount+1)*[math.inf]

        dp[0] = 0

        for i in range(1, amount+1):
            ans = math.inf
            for coin in coins:
                if i - coin >= 0:
                    ans = min(ans, dp[i - coin])
                
            dp[i] = ans + 1

        result = -1 if math.isinf(dp[amount]) else dp[amount]

        return result
```

#### [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)

```python
class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        
        # 递归

        # 从左往右，coins[index...]能凑成rest数额的硬币组合数
        # def process(coins, index, rest):
        #     if index == len(coins):
        #         return 1 if rest == 0 else 0

        #     ans = 0
        #     limit = rest // coins[index]
        #     for i in range(limit+1):
        #         ans += process(coins, index+1, rest - i * coins[index])

        #     return ans

        # return process(coins, 0, amount)

        # 动态规划
        m = len(coins)

        dp = [(amount+1) * [0] for _ in range(m+1)]

        dp[m][0] = 1

        for index in range(m-1, -1, -1):
            for rest in range(amount+1):

                # limit = rest // coins[index]
                # for k in range(limit+1):
                #     ans += dp[index+1][rest - k * coins[index]]

                # 通过依赖关系优化循环
                dp[index][rest] = dp[index+1][rest]
                if rest - coins[index] >= 0:
                    dp[index][rest] += dp[index][rest - coins[index]]

        return dp[0][amount]
```

#### [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

```python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:

        # # 递归

        # # 考虑index往后的位置，数组是否能凑成rest
        # def process(nums, index, rest):

        #     if index == len(nums):
        #         return True if rest == 0 else False

        #     # index还没有到末尾
        #     p1 = process(nums, index+1, rest)

        #     p2 = False
        #     if (nums[index] <= rest):
        #         p2 = process(nums, index+1, rest-nums[index])

        #     return p1 or p2

        sum_ = 0
        for num in nums:
            sum_ += num

        if sum_ % 2 == 1:
            return False

        # return process(nums, 0, sum_/2)

        # 动态规划
        n = len(nums)
        sum_ = sum_ // 2
        
        dp = [(sum_+1)*[False] for _ in range(n+1)]

        dp[n][0] = True

        for index in range(n-1, -1, -1):
            for rest in range(sum_+1):

                p1 = dp[index+1][rest]

                p2 = False
                if (nums[index] <= rest):
                    p2 = dp[index+1][rest - nums[index]]

                dp[index][rest] = (p1 or p2)

        return dp[0][sum_]
```

#### [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:

        # # 当前在index位置，能否达到最后一个小标
        # def process(nums, index):
        #     if index == len(nums) - 1:
        #         return True

        #     if nums[index] == 0:
        #         return False

        #     if nums[index] >= len(nums) - 1 - index:
        #         return True

        #     # index 没到末尾， nums[index]不够一步达到最后下标
        #     ans = False
        #     for i in range(1, nums[index]+1):
        #         if process(nums, index + i):
        #             ans = True
        #             break

        #     return ans


        # return process(nums, 0)

        # 动态规划
        if len(nums) < 2:
            return True

        n = len(nums)
        dp = n * [True]

        for index in range(n):
            if nums[index] == 0:
                dp[index] = False

        for index in range(n-2, -1, -1):

            if nums[index] >= len(nums) - 1 - index:
                dp[index] = True
                
            else:
                ans = False
                for i in range(1, nums[index]+1):
                    if dp[index+i]:
                        ans = True
                        break

                dp[index] = ans

        return dp[0]

        

            
```

#### [45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)

```python
class Solution:
    def jump(self, nums: List[int]) -> int:

        # # 递归

        # # 在index位置时，跳跃到最后位置的最少跳跃次数
        # def process(nums, index):

        #     if index == len(nums) - 1:
        #         return 0

        #     # index还未达到末尾位置
        #     if nums[index] == 0:
        #         return math.inf
        
        #	  # 如果此时的最大允许步数大于剩余距离，可以一步走完
        #     if nums[index] >= len(nums) - 1 - index:
        #         return 1
            
        #     min_step = process(nums, index + nums[index])
        #     for i in range(1, nums[index]):
        #         min_step = min(min_step, process(nums, index + i))

        #     return min_step + 1

        # return process(nums, 0)

        # 动态规划
        if len(nums) < 2:
            return 0
            
        n = len(nums)
        dp = (n)*[0]

        for index in range(n):
            if nums[index] == 0:
                dp[index] = math.inf

        for index in range(n-2, -1, -1):
            if nums[index] >= len(nums) - 1 - index:
                dp[index] = 1
            
            else:
                min_step = dp[index + nums[index]]
                for i in range(1, nums[index]):
                    min_step = min(min_step, dp[index + i])

                dp[index] = min_step + 1

        return dp[0]
```

### 路径问题

本身问题就是网格状的，dp就是和网格同样大小的数组。一般求最值或者个数，则dp是二维数组。如果有其他指标（剩余步数），dp可能演变为三维数组。

#### [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        # 记忆化递归

        # dp = [n * [0] for _ in range(m)]
        # # 机器人在(i, j)位置到终点的路径数
        # def process(i, j, m, n) -> int:
        #     if dp[i][j] != 0:
        #         return dp[i][j]

        #     ans = 0
        #     if i == m-1 or j == n-1:
        #         ans = 1
        #     else:
        #         ans = process(i+1, j, m, n) + process(i, j+1, m, n)

        #     dp[i][j] = ans
        #     return ans

        # return process(0, 0, m, n)

        # 动态规划
        dp = [n * [0] for _ in range(m)]

        # 边界条件
        for i in range(m):
            dp[i][n-1] = 1

        for j in range(n):
            dp[m-1][j] = 1

        for j in range(n-2, -1, -1):
            for i in range(m-2, -1, -1):
                dp[i][j] = dp[i+1][j] + dp[i][j+1]

        return dp[0][0]
```

#### [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

```python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:

        # 动态规划
        m = len(grid)
        n = len(grid[0])

        dp = [n * [0] for _ in range(m)]

        dp[m-1][n-1] = grid[m-1][n-1]

        for i in range(m-2, -1, -1):
            dp[i][n-1] = dp[i+1][n-1] + grid[i][n-1]

        for j in range(n-2, -1, -1):
            dp[m-1][j] = dp[m-1][j+1] + grid[m-1][j]

        for i in range(m-2, -1, -1):
            for j in range(n-2, -1, -1):
                dp[i][j] = grid[i][j] + min(dp[i+1][j], dp[i][j+1])

        return dp[0][0]
```

### 范围模型

考虑str[L...R]上的情况， 一般在需要比较开头和结尾相互关系时使用，例如回文。

#### [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

```python
def longestPalindrome(self, s: str) -> str:

    # n = len(s)
    # if n == 0:
    #     return ""

    # def extend(i, j, s):
    #     while(i >= 0 and j < len(s) and s[i] == s[j]):
    #         i -= 1
    #         j += 1
    #     return s[i + 1:j]

    # # 最长回文子串一定是以某个char为中心的最大外扩
    # res = s[0]
    # for i in range(n - 1):
    #     e1 = extend(i, i, s)
    #     e2 = extend(i, i + 1, s)
    #     if max(len(e1), len(e2)) > len(res):
    #         res = e1 if len(e1) > len(e2) else e2
            
    # return res

    # 动态规划
    n = len(s)
    if len(s) < 2:
        return s

    # 创建dp状态数组
    dp = [n * [False] for _ in range(n)]

    # 边界条件 
    for i in range(n):
        dp[i][i] = True

    # 记录最长字串的起始index和长度
    begin = 0
    max_len = 1
    # 沿着dp数组对角线遍历
    for length in range(2, n+1):

        for i in range(n):
            j = i + length - 1

            if j >= n:
                break

            if s[i] != s[j]:
                dp[i][j] = False
            else:
                if j - i <= 2:
                    dp[i][j] = True
                else:
                    dp[i][j] = dp[i+1][j-1]

            if dp[i][j] and length > max_len:
                begin = i
                max_len = length

    return s[begin: begin + max_len]
```

#### [516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

```python
class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:

        # # 递归
        # # str[left...right]上的最长回文子序列的长度
        # def process(s, left, right):
        #     if left == right:
        #         return 1

        #     if left == right - 1:
        #         return 2 if s[left] == s[right] else 1

        #     p1 = process(s, left+1, right-1)
        #     p2 = process(s, left, right-1)
        #     p3 = process(s, left+1, right)
        #     p4 = (process(s, left+1, right-1) + 2) if s[left] == s[right] else 0

        #     return max(p1, p2, p3, p4)

        # return process(s, 0, len(s)-1)

        # 动态规划
        n = len(s)
        dp = [n * [0] for _ in range(n)]

        dp[n-1][n-1] = 1
        for i in range(n-1):
            dp[i][i] = 1
            dp[i][i+1] = 2 if s[i] == s[i+1] else 1

        for i in range(n-3, -1, -1):
            for j in range(i+2, n):
                # p1 = dp[i+1][j-1] # 根据依赖关系可知 p1的值最小，无需参与比较
                # p2 = dp[i][j-1]
                # p3 = dp[i+1][j]
                # p4 = dp[i+1][j-1] + 2 if s[i] == s[j] else 0
            
                # 优化比较
                max_ = max(dp[i][j-1], dp[i+1][j])
                if s[i] == s[j]:
                    max_ = max(max_, dp[i+1][j-1] + 2)
                dp[i][j] = max_

        return dp[0][n-1]
```



### 样本对应模型

考虑两个序列str1[0...i]和str2[0...j]的相互关系。

#### [1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

```python
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:

        # # 递归

        # # str[0...i] 和 str[0...j] 上最长公共子序列的长度
        # def process(str1, str2, i, j) -> int:
        #     if i == 0 and j == 0:
        #         return 1 if str1[i] == str2[j] else 0

        #     elif i == 0 and j != 0:
        #         return 1 if str1[i] == str2[j] else process(str1, str2, i, j-1)

        #     elif i != 0 and j == 0:
        #         return 1 if str1[i] == str2[j] else process(str1, str2, i-1, j)

        #     else:

        #         # 以i结尾，但不一定以j结尾
        #         p1 = process(str1, str2, i, j-1)
        #         # 以j结尾，但不一定以i结尾
        #         p2 = process(str1, str2, i-1, j)
        #         # 一定以i和j结尾
        #         p3 = 1 + process(str1, str2, i-1, j-1) if str1[i] == str2[j] else 0

        #         return max(p1, p2, p3)

        # return process(text1, text2, len(text1)-1, len(text2)-1)

        # 动态规划
        if not text1 or not text2:
            return 0

        m = len(text1)
        n = len(text2)

        dp = [n*[0] for _ in range(m)]

        dp[0][0] = 1 if text1[0] == text2[0] else 0

        for i in range(1, m):
            dp[i][0] = 1 if text1[i] == text2[0] else dp[i-1][0]

        for j in range(1, n):
            dp[0][j] = 1 if text1[0] == text2[j] else dp[0][j-1]

        for i in range(1, m):
            for j in range(1, n):
                p1 = dp[i][j-1]
                p2 = dp[i-1][j]
                p3 = 1 + dp[i-1][j-1] if text1[i] == text2[j] else 0
                dp[i][j] = max(p1, p2, p3)

        return dp[m-1][n-1]
```

#### [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:

        # 动态规划

        m = len(word1)
        n = len(word2)

        dp = [(n+1)*[0] for _ in range(m+1)]

        dp[0][0] = 0

        for i in range(1, m+1):
            dp[i][0] = i

        for j in range(1, n+1):
            dp[0][j] = j

        for i in range(1, m+1):
            for j in range(1, n+1):
                p1 = dp[i][j-1] + 1
                p2 = dp[i-1][j] + 1
                p3 = dp[i-1][j-1]
                if word1[i-1] != word2[j-1]:
                    p3 += 1

                dp[i][j] = min(p1, p2, p3)

        return dp[m][n]
```

#### [97. 交错字符串](https://leetcode-cn.com/problems/interleaving-string/)

```
class Solution:
    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:

        # 递归

        # # s1[0...i] 和 s2[0...j] 是否能组成 s3[0...i+j]
        # def process(i, j, s1, s2, s3):
        #     if i == 0 and j == 0:
        #         return True

        #     elif i == 0 and j != 0:
        #         return s2[:j] == s3[:j]

        #     elif i != 0 and j == 0:
        #         return s1[:i] == s3[:i]

        #     # i, j均不等于0, s3 i+j-1位置上的字符要么来自s1, 要么来自s2

        #     else:
        #         ans = False
        #         if s1[i-1] == s3[i+j-1]:
        #             ans = ans or process(i-1, j, s1, s2, s3)

        #         if s2[j-1] == s3[i+j-1]:
        #             ans = ans or process(i, j-1, s1, s2, s3)
                
        #         return ans

        # if not s1:
        #     return s2 == s3

        # if not s2:
        #     return s1 == s3

        # if len(s1) + len(s2) != len(s3):
        #     return False

        # return process(len(s1), len(s2), s1, s2, s3)

        # 动态规划

        if len(s1) + len(s2) != len(s3):
            return False

        m = len(s1)
        n = len(s2)

        dp = [(n+1)*[False] for _ in range(m+1)]

        dp[0][0] = True
        for i in range(1, m+1):
            dp[i][0] = (s1[:i] == s3[:i])

        for j in range(1, n+1):
            dp[0][j] = (s2[:j] == s3[:j])

        for i in range(1, m+1):
            for j in range(1, n+1):
                ans = False
                if s1[i-1] == s3[i+j-1]:
                    ans = ans or dp[i-1][j]

                if s2[j-1] == s3[i+j-1]:
                    ans = ans or dp[i][j-1]
                
                dp[i][j] = ans

        return dp[m][n]
       
```

#### [115. 不同的子序列](https://leetcode-cn.com/problems/distinct-subsequences/)

```python
class Solution:
    def numDistinct(self, s: str, t: str) -> int:

        # # 递归

        # # 在s[0...i]中t[0...j]出现的个数
        # def process(i, j, s, t):
            
        #     if j == 0:
        #         return 1

        #     if i == 0:
        #         return 0

        #     if i < j:
        #         return 0

        #     # i, j 都不等于0，且i >= j
        #     if s[i-1] != t[j-1]:
        #         return process(i-1, j, s, t)

        #     else:
        #         return process(i-1, j, s, t) + process(i-1, j-1, s, t)
            
        # return process(len(s), len(t), s, t)

        # 动态规划
        m = len(s)
        n = len(t)

        dp = [(n+1)*[0] for _ in range(m+1)]

        for i in range(m+1):
            dp[i][0] = 1

        for i in range(1, m+1):
            for j in range(1, n+1):

                if i < j:
                    dp[i][j] = 0
                else:
                    # i, j 都不等于0，且i >= j
                    dp[i][j] = dp[i-1][j]
                    if s[i-1] == t[j-1]:
                        dp[i][j] += dp[i-1][j-1]
            
        return dp[m][n]
```

