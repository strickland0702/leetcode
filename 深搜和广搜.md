# DFS & BFS

### 网格搜索问题

#### [剑指 Offer 13. 机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)

```python
class Solution:
    def movingCount(self, m: int, n: int, k: int) -> int:

        # BFS 时间复杂度更优
        def bit_sum(x):
            return sum([int(i) for i in str(x)])

        # queue = collections.deque([(0, 0)])
        visited = set()

        # while queue:
        #     x, y = queue.popleft()

        #     if (x, y) not in visited and 0 <= x < m and 0 <= y < n and bit_sum(x) + bit_sum(y) <= k:
        #         visited.add((x, y))
        #         for nx, ny in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:
        #             queue.append((nx, ny))

        # return len(visited)

        # DFS

        def valid(x, y):
            if 0 <= x < m and 0 <= y < n and bit_sum(x) + bit_sum(y) <= k:
                return True

            return False

        def dfs(i, j):
            if (i, j) in visited:
                return

            visited.add((i, j))
            for nx, ny in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:
                if valid(nx, ny):
                    dfs(nx, ny)

        dfs(0, 0)
        return len(visited)


```



### DFS+回溯

#### [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:

        ans = []
        def backtrack(S, left, right):
            
            # 括号数量等于2n时，返回结果
            if len(S) == 2 * n:
                ans.append(''.join(S))
                return

            # 左括号小于n时，可以加入左括号
            if left < n:
                S.append('(')
                backtrack(S, left+1, right)

                # 需要回溯到加入之前
                S.pop()

            # 右括号少于左括号时，可以加入右括号
            if right < left:
                S.append(')')
                backtrack(S, left, right+1)
                S.pop()

        backtrack([], 0, 0)
        return ans

```

